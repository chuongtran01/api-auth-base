# Lombok Integration Guide

## üéØ **Overview**

This project uses **Lombok** to reduce boilerplate code and improve developer productivity. Lombok automatically generates common methods like getters, setters, constructors, equals, hashCode, and toString at compile time.

## üì¶ **Dependencies**

Lombok is added to the project via Maven dependency:

```xml
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>
```

## üîß **Lombok Annotations Used**

### **1. Entity Classes**

#### **@Getter & @Setter**

- **Purpose**: Automatically generates getter and setter methods for all fields
- **Usage**: Applied at class level for all fields
- **Benefits**: Eliminates hundreds of lines of boilerplate code

```java
@Entity
@Getter
@Setter
public class User {
    private String email;
    private String username;
    // No need to write getEmail(), setEmail(), etc.
}
```

#### **@NoArgsConstructor**

- **Purpose**: Generates a no-argument constructor
- **Usage**: `@NoArgsConstructor(access = AccessLevel.PROTECTED)` for JPA entities
- **Benefits**: Required by JPA for entity instantiation

```java
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class User {
    // JPA can create instances without calling constructors
}
```

#### **@AllArgsConstructor**

- **Purpose**: Generates a constructor with all fields as parameters
- **Usage**: Applied at class level
- **Benefits**: Useful for testing and builder pattern

```java
@AllArgsConstructor
public class User {
    // Constructor with all fields automatically generated
}
```

#### **@Builder**

- **Purpose**: Implements the Builder pattern
- **Usage**: Applied at class level
- **Benefits**: Provides fluent API for object creation

```java
@Builder
public class User {
    // Can now use: User.builder().email("test@example.com").build()
}
```

#### **@ToString**

- **Purpose**: Generates toString() method
- **Usage**: `@ToString(exclude = {"password", "refreshTokens"})` to exclude sensitive fields
- **Benefits**: Safe logging without exposing sensitive data

```java
@ToString(exclude = {"password", "refreshTokens"})
public class User {
    // toString() excludes password and refreshTokens for security
}
```

#### **@EqualsAndHashCode**

- **Purpose**: Generates equals() and hashCode() methods
- **Usage**: `@EqualsAndHashCode(exclude = {"createdAt", "updatedAt"})` to exclude audit fields
- **Benefits**: Proper object comparison without including temporal fields

```java
@EqualsAndHashCode(exclude = {"createdAt", "updatedAt"})
public class User {
    // equals() and hashCode() ignore audit fields
}
```

#### **@Builder.Default**

- **Purpose**: Provides default values for builder pattern
- **Usage**: Applied to fields with default values
- **Benefits**: Maintains default values when using builder

```java
@Builder.Default
private Boolean isEnabled = true;

@Builder.Default
private Set<Role> roles = new HashSet<>();
```

### **2. Configuration Classes**

#### **@Data**

- **Purpose**: Combines @Getter, @Setter, @ToString, @EqualsAndHashCode, and @RequiredArgsConstructor
- **Usage**: Applied to configuration classes
- **Benefits**: Complete data class functionality in one annotation

```java
@Component
@ConfigurationProperties(prefix = "cors")
@Data
public class CorsProperties {
    private List<String> allowedOriginPatterns = List.of("*");
    // All getters, setters, toString, equals, hashCode automatically generated
}
```

### **3. Controller Classes**

#### **@Slf4j**

- **Purpose**: Creates a logger field named `log`
- **Usage**: Applied at class level
- **Benefits**: Automatic logger creation without manual declaration

```java
@RestController
@Slf4j
public class HealthController {
    public void someMethod() {
        log.debug("Health check requested"); // No need to declare logger
    }
}
```

#### **@RequiredArgsConstructor**

- **Purpose**: Generates constructor for final fields
- **Usage**: Applied at class level
- **Benefits**: Constructor injection without manual constructor writing

```java
@RestController
@RequiredArgsConstructor
public class HealthController {
    private final SomeService someService; // Constructor automatically generated
}
```

## üö¶ **Understanding Lombok's AccessLevel**

Lombok's `AccessLevel` is an enumeration that lets you control the visibility (access modifier) of the methods or constructors generated by Lombok annotations such as `@NoArgsConstructor`, `@AllArgsConstructor`, `@Setter`, and `@Getter`.

### **AccessLevel Values**

| Value                  | Java Equivalent    | Description                            |
| ---------------------- | ------------------ | -------------------------------------- |
| `PUBLIC`               | `public`           | Visible everywhere                     |
| `MODULE`               | `module` (Java 9+) | Visible to classes in the same module  |
| `PROTECTED`            | `protected`        | Visible to subclasses and same package |
| `PACKAGE` or `DEFAULT` | (no modifier)      | Visible to classes in the same package |
| `PRIVATE`              | `private`          | Visible only within the same class     |

### **Why Use AccessLevel?**

- **Encapsulation:** Restrict how and where fields or constructors can be accessed.
- **JPA Compliance:** JPA entities require a protected or package-private no-args constructor.
- **Builder Pattern:** Prevent direct use of all-args constructors, enforce use of builder.
- **Security:** Prevent unwanted modification of sensitive fields.

### **Usage Examples in This Project**

#### 1. **JPA Entity No-Args Constructor**

```java
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class User { ... }
```

- Generates a protected no-argument constructor, as required by JPA.

#### 2. **Private All-Args Constructor for Builder**

```java
@AllArgsConstructor(access = AccessLevel.PRIVATE)
@Builder
public class User { ... }
```

- Generates a private all-arguments constructor, used only by Lombok's builder.

#### 3. **Private Setter for Sensitive Field**

```java
@Setter(AccessLevel.PRIVATE)
private String password;
```

- Only the class itself can set the password, but it can be read elsewhere if a getter is present.

### **Summary Table**

```java
// public constructor
@NoArgsConstructor(access = AccessLevel.PUBLIC)

// protected constructor
@NoArgsConstructor(access = AccessLevel.PROTECTED)

// package-private constructor
@NoArgsConstructor(access = AccessLevel.PACKAGE)

// private constructor
@NoArgsConstructor(access = AccessLevel.PRIVATE)
```

**In summary:**
Use `AccessLevel` to fine-tune the visibility of Lombok-generated methods and constructors, supporting best practices for encapsulation, security, and framework requirements (like JPA) in your codebase.

## üèóÔ∏è **Entity Refactoring Examples**

### **Before Lombok (User Entity)**

```java
@Entity
public class User {
    private Long id;
    private String email;
    private String username;
    // ... more fields

    // Default constructor
    protected User() {}

    // Constructor with fields
    public User(String email, String username, String password) {
        this.email = email;
        this.username = username;
        this.password = password;
    }

    // 20+ getter methods
    public Long getId() { return id; }
    public String getEmail() { return email; }
    public String getUsername() { return username; }
    // ... more getters

    // 20+ setter methods
    public void setId(Long id) { this.id = id; }
    public void setEmail(String email) { this.email = email; }
    public void setUsername(String username) { this.username = username; }
    // ... more setters

    // equals and hashCode
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        User user = (User) o;
        return email != null ? email.equals(user.email) : user.email == null;
    }

    @Override
    public int hashCode() {
        return email != null ? email.hashCode() : 0;
    }

    // toString
    @Override
    public String toString() {
        return "User{" +
            "id=" + id +
            ", email='" + email + '\'' +
            ", username='" + username + '\'' +
            // ... more fields
            '}';
    }
}
```

**Total: ~150 lines of boilerplate code**

### **After Lombok (User Entity)**

```java
@Entity
@Getter
@Setter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@Builder
@ToString(exclude = {"password", "refreshTokens"})
@EqualsAndHashCode(exclude = {"password", "refreshTokens", "createdAt", "updatedAt", "lastLoginAt"})
public class User {
    private Long id;
    private String email;
    private String username;
    // ... more fields

    // Constructor for creating users
    public User(String email, String username, String password) {
        this.email = email;
        this.username = username;
        this.password = password;
    }

    // Business logic methods only
    public void addRole(Role role) {
        this.roles.add(role);
        role.getUsers().add(this);
    }

    public String getFullName() {
        // Business logic implementation
    }
}
```

**Total: ~50 lines (67% reduction in boilerplate)**

## üéØ **Benefits of Lombok Integration**

### **1. Code Reduction**

- **67% reduction** in entity class lines
- **Eliminates 100+ lines** of boilerplate per entity
- **Faster development** with less typing

### **2. Maintainability**

- **Single source of truth** for field definitions
- **Automatic updates** when fields change
- **Consistent patterns** across all classes

### **3. Security**

- **Safe toString()** with sensitive field exclusion
- **Proper equals/hashCode** without audit fields
- **Controlled access** with protected constructors

### **4. Developer Experience**

- **Builder pattern** for fluent object creation
- **Automatic logging** with @Slf4j
- **Constructor injection** with @RequiredArgsConstructor

### **5. Performance**

- **Compile-time generation** (no runtime overhead)
- **Optimized bytecode** for generated methods
- **No reflection** required

## üîß **IDE Setup**

### **IntelliJ IDEA**

1. Install Lombok plugin: `File ‚Üí Settings ‚Üí Plugins ‚Üí Search "Lombok"`
2. Enable annotation processing: `File ‚Üí Settings ‚Üí Build, Execution, Deployment ‚Üí Compiler ‚Üí Annotation Processors ‚Üí Enable annotation processing`

### **Eclipse**

1. Download lombok.jar from https://projectlombok.org/download
2. Run: `java -jar lombok.jar`
3. Follow installation instructions

### **VS Code**

1. Install "Lombok Annotations Support for VS Code" extension
2. Configure Java extension settings

## üß™ **Testing with Lombok**

### **Builder Pattern Usage**

```java
@Test
public void testUserCreation() {
    User user = User.builder()
        .email("test@example.com")
        .username("testuser")
        .password("password123")
        .firstName("John")
        .lastName("Doe")
        .isEnabled(true)
        .build();

    assertThat(user.getEmail()).isEqualTo("test@example.com");
    assertThat(user.getUsername()).isEqualTo("testuser");
}
```

### **Constructor Usage**

```java
@Test
public void testUserConstructor() {
    User user = new User("test@example.com", "testuser", "password123");

    assertThat(user.getEmail()).isEqualTo("test@example.com");
    assertThat(user.getUsername()).isEqualTo("testuser");
}
```

## üöÄ **Best Practices**

### **1. Entity Annotations**

```java
@Entity
@Getter
@Setter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@Builder
@ToString(exclude = {"password", "sensitiveData"})
@EqualsAndHashCode(exclude = {"auditFields", "temporalFields"})
public class EntityClass {
    // Fields and business logic only
}
```

### **2. Configuration Classes**

```java
@Component
@ConfigurationProperties(prefix = "app")
@Data
public class AppProperties {
    // Properties with default values
}
```

### **3. Controllers**

```java
@RestController
@Slf4j
@RequiredArgsConstructor
public class ApiController {
    private final SomeService someService;

    @GetMapping("/endpoint")
    public ResponseEntity<?> handleRequest() {
        log.debug("Request received");
        // Implementation
    }
}
```

### **4. DTOs (Future Use)**

```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserDto {
    private Long id;
    private String email;
    private String username;
    // No sensitive fields like password
}
```

## üîç **Generated Code Inspection**

To see the generated code:

1. **IntelliJ IDEA**: `View ‚Üí Show Bytecode` or use Lombok plugin
2. **Eclipse**: Use Lombok plugin features
3. **Maven**: `mvn compile` and check target/generated-sources

## üìö **Additional Resources**

- [Lombok Official Documentation](https://projectlombok.org/features/all)
- [Lombok GitHub Repository](https://github.com/rzwitserloot/lombok)
- [Spring Boot + Lombok Best Practices](https://spring.io/guides/gs/spring-boot/)

## üéâ **Summary**

Lombok integration provides:

- ‚úÖ **67% code reduction** in entity classes
- ‚úÖ **Improved security** with safe toString() and equals()
- ‚úÖ **Better developer experience** with builder pattern
- ‚úÖ **Automatic logging** and constructor injection
- ‚úÖ **Zero runtime overhead** (compile-time generation)
- ‚úÖ **Consistent patterns** across the codebase

The project now uses Lombok extensively while maintaining all the benefits of clean, maintainable, and secure code.
